{"mappings":"AAiBA,wBAAgB,MAAM,EAAE,MAAM,QAG7B;AACD,6BAAqB,WAAW,EAAE,MAAM,QAGvC;AACD,6BAAqB,WAAW,EAAE,MAAM,QAGvC;AAED;;;;;;;IAOI;AACJ,qCACE,SAAS,EAAE,MAAM,EACjB,SAAS,CAAC,EAAE,OAAO,EACnB,KAAK,CAAC,EAAE,MAAM,EACd,KAAK,CAAC,EAAE,OAAO,GACd,OAAO,CAAC,GAAG,CAAC,CAcd;AAED,kCAA0B,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC,CAKpE;AAED,mCAA2B,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAQnE;AACD,iCAAyB,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAGjE;AACD,8BACE,MAAM,GAAE,MAAY,EACpB,kBAAkB,GAAE,OAAe,GAClC,OAAO,CAAC,GAAG,CAAC,CAEd;AAED,iCAAyB,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAOjE;AAED,0BAAkB,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAE5C;AACD,qCAA6B,OAAO,CAAC,MAAM,CAAC,CAE3C;AAED,gCAAwB,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAElD;AACD,kCAA0B,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAMtD;AACD,4CAEC;AAED,kCAA0B,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CASlE;AAED;;;;;;;;GAQG;AACH,2BAAmB,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC;IAC3C,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,MAAM,CAAC;IACjB,MAAM,EAAE,MAAM,CAAC;IACf,IAAI,EAAE,MAAM,CAAC;CACd,CAAC,CAED;AAED,gCAAwB,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAGhD;AAED,+BACE,OAAO,EAAE,MAAM,EACf,SAAS,EAAE,MAAM,EACjB,OAAO,EAAE,MAAM,GACd,OAAO,CAAC,OAAO,CAAC,CAGlB;;;;;;;;;;;;;;;;;;;;;;;AASD,wBAsBE","sources":["index.ts"],"sourcesContent":["import { getRPC, methods } from \"@neuraiproject/neurai-rpc\";\n\nconst ONE_FULL_COIN = 1e8;\n\nconst URL_MAINNET = \"https://rpc-main.neurai.org/rpc\";\nconst URL_TESTNET = \"https://rpc-testnet.neurai.org/rpc\";\n\nlet username = \"anonymous\";\nlet password = \"anonymous\";\nlet url = URL_MAINNET;\n\nlet rpc = getRPC(username, password, url);\n\nfunction resetRPC() {\n  rpc = getRPC(username, password, url);\n  return rpc;\n}\nfunction setURL(newURL: string) {\n  url = newURL;\n  resetRPC();\n}\nfunction setUsername(newUsername: string) {\n  username = newUsername;\n  resetRPC();\n}\nfunction setPassword(newPassword: string) {\n  password = newPassword;\n  resetRPC();\n}\n\n/**\n  * \n  * @param assetName mandatory\n  * @param onlytotal otional, when false result is just a list of addresses with balances -- when true the result is just a single number representing the number of addresses\n  * @param count (integer, optional, default=50000, MAX=50000) truncates results to include only the first _count_ assets found\n  * @param start (integer, optional, default=0) results skip over the first _start_ assets found (if negative it skips back from the end)\n  \n  */\nfunction getAddressesByAsset(\n  assetName: string,\n  onlytotal?: boolean,\n  count?: number,\n  start?: boolean\n): Promise<any> {\n  const _onlytotal = onlytotal === undefined ? false : onlytotal;\n  let _count = count === undefined ? 5000 : count;\n  let _start = start === undefined ? 0 : start;\n  if (_count > 50000) {\n    _count = 50000;\n  }\n\n  return rpc(methods.listaddressesbyasset, [\n    assetName,\n    _onlytotal,\n    _count,\n    _start,\n  ]);\n}\n\nfunction getAddressDeltas(address: string | string[]): Promise<any[]> {\n  const addresses = turnIntoStringArray(address);\n  const assetName = \"\"; //Must be empty string, NOT \"*\"\n  const deltas = rpc(methods.getaddressdeltas, [{ addresses, assetName }]);\n  return deltas;\n}\n\nfunction getAddressMempool(address: string | string[]): Promise<any> {\n  const addresses = turnIntoStringArray(address); //Support both string and string array\n\n  const includeAssets = true;\n  return rpc(methods.getaddressmempool, [\n    { addresses: addresses },\n    includeAssets,\n  ]);\n}\nfunction getAddressUTXOs(address: string | string[]): Promise<any> {\n  const addresses = turnIntoStringArray(address); //Support both string and string array\n  return rpc(methods.getaddressutxos, [{ addresses: addresses }]);\n}\nfunction getAllAssets(\n  prefix: string = \"*\",\n  includeAllMetaData: boolean = false\n): Promise<any> {\n  return rpc(methods.listassets, [prefix, includeAllMetaData]);\n}\n\nfunction getAssetBalance(address: string | string[]): Promise<any> {\n  const addresses = turnIntoStringArray(address);\n  const includeAssets = true;\n  return rpc(methods.getaddressbalance, [\n    { addresses: addresses },\n    includeAssets,\n  ]);\n}\n\nfunction getAsset(name: string): Promise<any> {\n  return rpc(methods.getassetdata, [name]);\n}\nfunction getBestBlockHash(): Promise<string> {\n  return rpc(methods.getbestblockhash, []);\n}\n\nfunction getBlockByHash(hash: string): Promise<any> {\n  return rpc(methods.getblock, [hash]);\n}\nfunction getBlockByHeight(height: number): Promise<any> {\n  return rpc(methods.getblockhash, [height]).then((hash) => {\n    const verbosity = 3; //include transactions\n    const block = rpc(methods.getblock, [hash, verbosity]);\n    return block;\n  });\n}\nfunction getMempool() {\n  return rpc(methods.getrawmempool, [true]);\n}\n\nfunction getNeuraiBalance(address: string | string[]): Promise<any> {\n  const addresses = turnIntoStringArray(address);\n  if (!addresses || addresses.length < 1) {\n    const emptyObject = {};\n    return Promise.resolve(emptyObject);\n  }\n  const includeAssets = false;\n  const params = [{ addresses: addresses }, includeAssets];\n  return rpc(methods.getaddressbalance, params);\n}\n\n/**\n * Get the public key for an address\n * @param address The Neurai address to query\n * @returns Object with address, pubkey, revealed status, height, and txid\n * - revealed: 1 if pubkey has been revealed on-chain, 0 if not\n * - pubkey: The public key (empty string if not revealed)\n * - height: Block height where pubkey was first revealed (0 if not revealed)\n * - txid: Transaction ID where pubkey was first revealed (empty string if not revealed)\n */\nfunction getPubKey(address: string): Promise<{\n  address: string;\n  pubkey: string;\n  revealed: number;\n  height: number;\n  txid: string;\n}> {\n  return rpc(\"getpubkey\", [address]);\n}\n\nfunction getTransaction(id: string): Promise<any> {\n  const verbose = true;\n  return rpc(methods.getrawtransaction, [id, verbose]);\n}\n\nfunction verifyMessage(\n  address: string,\n  signature: string,\n  message: string\n): Promise<boolean> {\n  const params = [address, signature, message];\n  return rpc(methods.verifymessage, params);\n}\n\nfunction turnIntoStringArray(str: string | string[]): string[] {\n  if (typeof str === \"string\") {\n    return [str];\n  }\n  return str;\n}\n\nexport default {\n  getAddressesByAsset,\n  getAddressDeltas,\n  getAddressMempool,\n  getAddressUTXOs,\n  getAllAssets,\n  getAsset,\n  getAssetBalance,\n  getBestBlockHash,\n  getBlockByHash,\n  getBlockByHeight,\n  getMempool,\n  getNeuraiBalance,\n  getPubKey,\n  getTransaction,\n  setUsername,\n  setPassword,\n  setURL,\n  verifyMessage,\n\n  URL_MAINNET,\n  URL_TESTNET,\n};\n"],"names":[],"version":3,"file":"types.d.ts.map"}